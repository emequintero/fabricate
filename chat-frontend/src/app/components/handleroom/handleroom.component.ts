import { Component, OnDestroy, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { Request } from 'src/app/models/request';
import { Room } from 'src/app/models/room';
import { User } from 'src/app/models/user';
import { ChatService } from 'src/app/services/chat.service';
import { NavigationService } from 'src/app/services/navigation.service';
import { RoomService } from 'src/app/services/room.service';
import { UserService } from 'src/app/services/user.service';

@Component({
  selector: 'app-handleroom',
  templateUrl: './handleroom.component.html',
  styleUrls: ['./handleroom.component.sass']
})
export class HandleroomComponent implements OnInit, OnDestroy{
  availableUsers:Array<User> = null;
  selectedUsers:Array<User> = new Array<User>();
  curUser:User = null;
  roomsCurUser:Array<Room> = new Array<Room>();
  selectedRoom:Room = null;
  requestMatch:boolean = false;
  mode:string;
  isFormValid:boolean = true;
  enterRoomSub:Subscription = new Subscription();
  curUserSub:Subscription = new Subscription();
  roomsCurUserSub:Subscription = new Subscription();
  watchRoomsCurUserSub:Subscription = new Subscription();
  availableUsersSub:Subscription = new Subscription();
  selectedRoomSub = new Subscription();
  constructor(private chatService:ChatService, private roomService:RoomService, 
    private userService:UserService, private router:Router, private route:ActivatedRoute, 
    private navigationService:NavigationService) { }
  ngOnDestroy(): void {
    //unsubscribe to events/updates
    this.enterRoomSub.unsubscribe();
    this.curUserSub.unsubscribe();
    this.roomsCurUserSub.unsubscribe();
    this.watchRoomsCurUserSub.unsubscribe();
    this.availableUsersSub.unsubscribe();
    this.selectedRoomSub.unsubscribe();
  }

  ngOnInit(): void {
    //reset selected users on load
    this.selectedUsers = new Array<User>();
    //get handle room mode (create/add)
    this.mode = this.route.snapshot.paramMap.get('mode');
    
    this.curUserSub = this.userService.getUser().subscribe((user)=>{
      this.curUser = user;
    });
    this.roomsCurUserSub = this.roomService.getRoomsCurUser().subscribe((roomsCurUser:Array<Room>)=>{
      this.roomsCurUser = roomsCurUser;
    });
    //get online users
    this.availableUsersSub = this.chatService.getAvailableUsers().subscribe(users=>{
      //handle room mode='add' will subscribe to selectedRoom
      if(this.mode === 'add'){
        this.selectedRoomSub = this.roomService.getRoom().subscribe((selectedRoom:Room)=>{
          this.selectedRoom = selectedRoom;
          //handle room mode='add' will filter out availableUsers that are already in room
          let formattedUsers = users.map(user=>{
            return new User(user.profilePic, user.username, user.userID, user.role);
          });
          this.availableUsers = formattedUsers.filter((user:User)=>{
            return !this.selectedRoom.users.some((existingUser:User)=>{
              return existingUser.userID === user.userID;
            });
          });
        });
      }
      else if(this.mode === 'create'){
        this.availableUsers = users.map(user=>{
          return new User(user.profilePic, user.username, user.userID, user.role);
        });
      }
    });
    this.watchRoomsCurUserSub = this.chatService.watchCurUserRooms().subscribe((roomsCurUser:Array<Room>)=>{
      //update rooms for current user in shareable resource
      let updatedRoomsCurUser = roomsCurUser.map(room=>{
        return new Room(room.users, room.messages, room.roomID);
      });
      //update roomsCurUser in shareable resource
      this.roomService.setRoomsCurUser(updatedRoomsCurUser);
    });
  }

  enterRoom(){
    //add current user to list of included users
    this.selectedUsers.push(this.curUser);
    //pre-check if room already exists (avoids duplicates if user combination exists)
    let existingRoom = this.roomsCurUser.find((room:Room)=>{
      return JSON.stringify(room.users.sort(this.compareUsers)) === JSON.stringify(this.selectedUsers.sort(this.compareUsers));
    });
    let selectedRoom = existingRoom ? new Room(existingRoom.users,existingRoom.messages,existingRoom.roomID) : new Room(this.selectedUsers);
    //enter room
    this.enterRoomSub = this.chatService.enterRoom(this.curUser, selectedRoom).subscribe((updatedSelectedRoom:Room)=>{
      //check if room already exists (users denying request can alter rooms)
      let roomAlreadyExists = this.roomsCurUser.find((room:Room)=>{
        return updatedSelectedRoom.roomID === room.roomID;
      });
      //update current room with returned room ID (generated by backend)
      selectedRoom = new Room(updatedSelectedRoom.users, updatedSelectedRoom.messages, updatedSelectedRoom.roomID);
      //update room in shareable resource
      this.roomService.setRoom(selectedRoom);
      //redirect to chat room
      this.router.navigate(['chat-room']);
      //only send requests if room doesn't already exist
      if(!roomAlreadyExists){
        //send requests to other users added to room (not curUser)
        selectedRoom.users.forEach((user:User)=>{
          if(user.userID !== this.curUser.userID){
            this.chatService.sendRequest(this.curUser, user, selectedRoom);
          }
        });
      }
    });
  }

  addRoomUsers(){
    //combine selected users and user list in selected room for complete list of included users
    this.selectedRoom.users = [...this.selectedRoom.users, ...this.selectedUsers];
    //send requests to other users added to room (not curUser)
    this.selectedUsers.forEach((user:User)=>{
      if(user.userID !== this.curUser.userID){
        this.chatService.sendRequest(this.curUser, user, this.selectedRoom);
      }
    });
    //redirect to chat room
    this.router.navigate(['chat-room']);
  }

  submit(){
    this.isFormValid = this.selectedUsers.length !== 0;
    if(this.isFormValid){
      if(this.mode === 'create'){
        this.enterRoom();
      }
      else if(this.mode === 'add'){
        this.addRoomUsers();
      }
    }
  }

  handleUser(user:User, op:string){
    //reset form error message
    if(!this.isFormValid)
      this.isFormValid = true;
    if(op === 'add'){
      this.selectedUsers.push(user);
    }
    else if(op === 'remove'){
      this.selectedUsers.splice(this.selectedUsers.indexOf(user), 1);
    }
  }

  handleDisableSubmit(){
    //check requests to see if users match
    let duplicateRoom = this.curUser.requests.filter((request:Request)=>{
      //use only userIDs to compare correctly
      let roomUserIDs:Array<string> = request.room.users.map((user:User)=>{
        return user.userID;
      });
      let selectedUserIDs:Array<string> = this.selectedUsers.map((user:User)=>{
        return user.userID;
      });
      selectedUserIDs.push(this.curUser.userID);
      return JSON.stringify(roomUserIDs.sort()) === JSON.stringify(selectedUserIDs.sort());
    });
    //handle displaying found request message
    this.requestMatch = duplicateRoom.length !== 0;
    //disable if request with same users exists
    if(this.requestMatch) return true;
    //if no request matches check if some users are selected
    else return !this.selectedUsers?.length;
  }

  isUserSelected(user:User){
    return this.selectedUsers.indexOf(user) !== -1;
  }

  //sort user array by username
  compareUsers = (a,b) =>{
    return a.username.localeCompare(b.username);
  }

  back(){
    this.navigationService.back();
  }

}
